default_platform(:android)

platform :android do
  desc "Runs all the tests"
  lane :test do
    gradle(task: "test")
  end

  desc "Build the Android App Bundle (AAB) using Flutter"
  lane :build_flutter do |options|
    version_code = options[:version_code]
    version_name = options[:version_name]
    
    # Constr√≥i o comando flutter build
    build_args = ["build", "appbundle", "--release"]
    build_args << "--build-number=#{version_code}" if version_code
    build_args << "--build-name=#{version_name}" if version_name

    # Executa o build do Flutter na raiz do projeto (../)
    Dir.chdir("..") do
      sh("flutter", *build_args)
    end
  end

  desc "Deploy a new version to the Google Play Internal Track"
  lane :internal do |options|
    # 1. Carregar credenciais
    
    # 2. Buscar vers√£o atual na loja
    begin
      current_codes = google_play_track_version_codes(track: 'internal')
      max_code = current_codes.max || 0
      prod_codes = google_play_track_version_codes(track: 'production')
      max_prod = prod_codes.max || 0
      
      current_version_code = [max_code, max_prod].max
    rescue => ex
      UI.error("Erro ao buscar vers√£o na loja: #{ex}")
      current_version_code = 0
    end

    new_version_code = current_version_code + 1
    UI.message("Version Code atual na loja: #{current_version_code}. Novo Version Code: #{new_version_code}")

    # 3. Buildar com o novo c√≥digo
    build_flutter(version_code: new_version_code)
    
    # 4. Upload (only binary, no metadata for RC)
    upload_to_play_store(
      track: 'internal',
      aab: '../build/app/outputs/bundle/release/app-release.aab',
      skip_upload_apk: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      skip_upload_metadata: true,
      skip_upload_changelogs: true
    )
  end

  desc "Deploy to Internal Track with Metadata and Screenshots"
  lane :deploy_with_metadata do |options|
    # Default track is internal, but can be overridden (e.g., 'production')
    track = options[:track] || 'internal'
    
    # Op√ß√µes para pular uploads se n√£o houver altera√ß√µes (detectado pelo CI)
    skip_screenshots = options[:skip_screenshots] || false
    skip_images = options[:skip_images] || false
    skip_metadata = options[:skip_metadata] || false

    # 1. Carregar credenciais (garante que json_key_data esteja dispon√≠vel se precisar)
    
    # 2. Buscar vers√£o atual na loja
    begin
      current_codes = google_play_track_version_codes(track: 'internal')
      max_code = current_codes.max || 0
      prod_codes = google_play_track_version_codes(track: 'production')
      max_prod = prod_codes.max || 0
      
      current_version_code = [max_code, max_prod].max
    rescue => ex
      UI.error("Erro ao buscar vers√£o na loja: #{ex}")
      current_version_code = 0
    end

    new_version_code = current_version_code + 1
    UI.message("Version Code atual na loja: #{current_version_code}. Novo Version Code: #{new_version_code}")

    # 3. Buildar com o novo c√≥digo
    build_flutter(version_code: new_version_code)

    # Define o caminho padr√£o ou usa a vari√°vel de ambiente se dispon√≠vel
    json_key_path = 'fastlane/play_store_credentials.json'
    json_key_data = ENV['ANDROID_PLAY_STORE_CREDENTIALS']

    # 4. Upload completo
    upload_to_play_store(
      track: track,
      aab: '../build/app/outputs/bundle/release/app-release.aab',
      # Usa o conte√∫do da vari√°vel de ambiente se existir, sen√£o usa o arquivo
      json_key_data: json_key_data, 
      json_key: json_key_data ? nil : json_key_path,
      skip_upload_apk: true,
      skip_upload_images: skip_images,      # Din√¢mico
      skip_upload_screenshots: skip_screenshots, # Din√¢mico
      skip_upload_metadata: skip_metadata     # Din√¢mico
    )
  end
  desc "Promote Internal to Production"
  lane :promote_to_production do |options|
    skip_screenshots = options[:skip_screenshots] || false

    # Get the version code from internal track
    version_codes = google_play_track_version_codes(track: 'internal')
    version_code = version_codes.max

    UI.message("Promoting version code #{version_code} from internal to production")

    upload_to_play_store(
      track: 'internal',
      track_promote_to: 'production',
      version_code: version_code,       # Specify version code for changelogs
      skip_upload_apk: true,
      skip_upload_aab: true,
      skip_upload_metadata: false,      # Always upload metadata
      skip_upload_changelogs: false,    # Always upload changelogs
      skip_upload_images: skip_screenshots,
      skip_upload_screenshots: skip_screenshots,
      timeout: 900                      # 15 minutes timeout for multi-locale uploads (3 locales √ó ~3-5min each)
    )
  end

  desc "Capture screenshots automatically using Flutter integration tests"
  lane :screenshots do |options|
    device = options[:device]
    avd_name = options[:avd] || options[:avd_name]
    locale = options[:locale] || "pt-BR"
    force_logout = options[:force_logout]

    # If AVD name provided, boot automatically. Otherwise use existing device.
    if avd_name
      UI.message("ü§ñ Will boot emulator automatically: #{avd_name}")
    elsif device
      UI.message("üì± Using existing device: #{device}")
    else
      UI.user_error!("‚ùå Must provide either :device or :avd parameter")
    end

    capture_screenshots_for_device(
      device: device,
      folder_name: "phoneScreenshots",
      locale: locale,
      force_logout: force_logout,
      avd_name: avd_name
    )
  end

  desc "Capture screenshots for all locales and all device types"
  lane :screenshots_all do |options|
    # AVD names (can be customized via options)
    # Run `emulator -list-avds` to see your available AVDs
    phone_avd = options[:phone_avd] || "Pixel_7"
    tablet7_avd = options[:tablet7_avd] || "Pixel_Tablet"
    tablet10_avd = options[:tablet10_avd] || "Pixel_Tablet"  # Using same as 7" if no 10" available

    force_logout = options[:force_logout]
    # Parallel is NOT supported when using auto-boot (emulators conflict)
    parallel = false
    locales = ["pt-BR", "en-US", "es-ES"]

    UI.important("ü§ñ Emulators will be started automatically!")
    UI.message("   üì± Phone: #{phone_avd}")
    UI.message("   üìü Tablet 7\": #{tablet7_avd}")
    UI.message("   üíª Tablet 10\": #{tablet10_avd}")

    same_tablet_avd = (tablet7_avd == tablet10_avd)
    if same_tablet_avd
      UI.important("‚ö†Ô∏è 7\" and 10\" tablet use the same AVD (#{tablet7_avd}). Will copy 7\" screenshots to 10\" folder.")
    end

    locales.each do |locale|
      UI.message("üåç Generating screenshots for locale: #{locale}")
      UI.message("üêå Running devices in SEQUENTIAL mode (auto-boot)")

      # Phone
      capture_screenshots_for_device(
        device: nil,  # Will be determined after boot
        folder_name: "phoneScreenshots",
        locale: locale,
        force_logout: force_logout,
        avd_name: phone_avd
      )

      # 7-inch Tablet
      capture_screenshots_for_device(
        device: nil,
        folder_name: "sevenInchScreenshots",
        locale: locale,
        force_logout: force_logout,
        avd_name: tablet7_avd
      )

      # 10-inch Tablet
      if same_tablet_avd
        # Same AVD as 7" ‚Äî copy screenshots instead of re-running
        # Use absolute paths to avoid working directory ambiguity
        project_root = File.expand_path("../..", __FILE__)  # android/fastlane/Fastfile -> project root
        src_dir = File.join(project_root, "android", "fastlane", "metadata", "android", locale, "images", "sevenInchScreenshots")
        dst_dir = File.join(project_root, "android", "fastlane", "metadata", "android", locale, "images", "tenInchScreenshots")

        UI.message("üìã Copying 7\" screenshots to 10\" folder for #{locale}")
        UI.message("   Source: #{src_dir}")
        UI.message("   Dest:   #{dst_dir}")

        FileUtils.mkdir_p(dst_dir)
        FileUtils.rm_rf(Dir.glob("#{dst_dir}/*.png"))
        screenshots = Dir.glob("#{src_dir}/*.png")
        UI.message("   Found #{screenshots.length} screenshots to copy")
        screenshots.each { |f| FileUtils.cp(f, dst_dir) }

        if screenshots.length > 0
          UI.success("üìã Copied #{screenshots.length} screenshots from 7\" to 10\" folder (#{locale})")
        else
          UI.error("‚ö†Ô∏è No 7\" screenshots found to copy for #{locale}. Check if sevenInchScreenshots ran successfully.")
        end
      else
        capture_screenshots_for_device(
          device: nil,
          folder_name: "tenInchScreenshots",
          locale: locale,
          force_logout: force_logout,
          avd_name: tablet10_avd
        )
      end
    end

    UI.success("‚úÖ All screenshots generated for #{locales.length} locales!")
  end

  desc "Capture screenshots only for pt-BR (backwards compatibility)"
  lane :screenshots_pt_br do |options|
    phone_device = options[:phone_device] || "emulator-5554"
    tablet7_device = options[:tablet7_device] || "emulator-5556"
    tablet10_device = options[:tablet10_device] || "emulator-5558"
    force_logout = options[:force_logout]

    # Phone
    capture_screenshots_for_device(
      device: phone_device,
      folder_name: "phoneScreenshots",
      locale: "pt-BR",
      force_logout: force_logout
    )

    # 7-inch Tablet
    capture_screenshots_for_device(
      device: tablet7_device,
      folder_name: "sevenInchScreenshots",
      locale: "pt-BR",
      force_logout: force_logout
    )

    # 10-inch Tablet
    capture_screenshots_for_device(
      device: tablet10_device,
      folder_name: "tenInchScreenshots",
      locale: "pt-BR",
      force_logout: force_logout
    )
  end

  # Helper function to get Android SDK path
  def get_android_sdk_path
    # Try ANDROID_HOME or ANDROID_SDK_ROOT environment variables
    sdk_path = ENV['ANDROID_HOME'] || ENV['ANDROID_SDK_ROOT']

    # If not set, try common locations
    if sdk_path.nil? || sdk_path.empty?
      common_paths = [
        File.expand_path("~/Library/Android/sdk"),     # macOS default
        File.expand_path("~/Android/Sdk"),             # Linux default
        "/usr/local/android-sdk"                       # Alternative
      ]

      sdk_path = common_paths.find { |path| Dir.exist?(path) }
    end

    if sdk_path.nil?
      UI.user_error!("‚ùå Android SDK not found. Please set ANDROID_HOME environment variable or install Android SDK.")
    end

    sdk_path
  end

  # Helper function to boot and reset emulator
  def boot_emulator(avd_name:, locale:)
    UI.message("üîÑ Preparing emulator: #{avd_name} with locale: #{locale}")

    # Get Android SDK paths
    sdk_path = get_android_sdk_path
    adb = File.join(sdk_path, "platform-tools", "adb")
    emulator = File.join(sdk_path, "emulator", "emulator")

    UI.message("Using Android SDK: #{sdk_path}")

    # 1. Kill emulator if already running
    UI.message("Killing any existing emulator instances...")
    sh("#{adb} devices | grep emulator | cut -f1 | xargs -I {} #{adb} -s {} emu kill || true")
    sleep(2)

    # 2. Start emulator fresh (no snapshot, wipe data for clean state)
    UI.message("üöÄ Starting emulator: #{avd_name}")
    spawn("#{emulator} -avd #{avd_name} -no-snapshot-load -no-audio -no-boot-anim")

    # 3. Wait for emulator to boot (check boot_completed property)
    UI.message("‚è≥ Waiting for emulator to boot...")
    max_attempts = 60
    attempts = 0
    booted = false

    while attempts < max_attempts && !booted
      sleep(5)
      attempts += 1

      # Get first emulator device
      device = `#{adb} devices | grep emulator | head -1 | cut -f1`.strip

      if !device.empty?
        boot_status = `#{adb} -s #{device} shell getprop sys.boot_completed 2>/dev/null`.strip
        if boot_status == "1"
          booted = true
          UI.message("‚úÖ Emulator booted: #{device}")

          # 4. Set locale
          UI.message("üåç Setting locale to: #{locale}")

          # Map locale to Android format (Android uses underscore: pt_BR, not pt-BR)
          android_locale = case locale
            when "pt-BR" then "pt_BR"
            when "en-US" then "en_US"
            when "es-ES" then "es_ES"
            else "en_US"
          end

          # Extract language and country for Android settings
          lang_parts = android_locale.split('_')
          language = lang_parts[0]
          country = lang_parts[1] || ""

          # Set system locale using multiple methods for better compatibility
          UI.message("Setting Android locale: #{android_locale} (lang: #{language}, country: #{country})")

          # Method 1: persist.sys.locale (requires root on some devices)
          sh("#{adb} -s #{device} shell setprop persist.sys.locale #{android_locale}") rescue nil

          # Method 2: system_locales setting
          sh("#{adb} -s #{device} shell settings put system system_locales #{android_locale}") rescue nil

          # Method 3: global settings for language and country
          sh("#{adb} -s #{device} shell settings put global system_language #{language}") rescue nil
          sh("#{adb} -s #{device} shell settings put global system_country #{country}") rescue nil

          # Method 4: secure settings (works on more Android versions)
          sh("#{adb} -s #{device} shell settings put secure system_locales #{android_locale}") rescue nil

          # 5. Restart UI to apply locale
          UI.message("Restarting UI to apply locale...")
          sh("#{adb} -s #{device} shell stop") rescue nil
          sleep(2)
          sh("#{adb} -s #{device} shell start") rescue nil
          sleep(5)

          # 6. Wait for boot_completed again after restart
          UI.message("‚è≥ Waiting for UI to restart...")
          wait_attempts = 0
          ui_ready = false
          while wait_attempts < 20 && !ui_ready
            sleep(2)
            wait_attempts += 1
            boot_status = `#{adb} -s #{device} shell getprop sys.boot_completed 2>/dev/null`.strip
            if boot_status == "1"
              ui_ready = true
              UI.success("‚úÖ Emulator ready: #{device} (locale: #{locale})")
            end
          end

          return device
        end
      end
    end

    UI.error("‚ùå Emulator failed to boot after #{max_attempts * 5} seconds")
    nil
  end

  # Helper function to run the screenshot process (light mode only)
  def capture_screenshots_for_device(device:, folder_name:, locale:, force_logout:, avd_name: nil)
    UI.message("üì∏ Capturing screenshots for #{folder_name} on device: #{device}, locale: #{locale}")

    # Boot emulator if AVD name provided
    if avd_name
      actual_device = boot_emulator(avd_name: avd_name, locale: locale)
      if actual_device.nil?
        UI.error("‚ö†Ô∏è Failed to boot emulator, skipping screenshots")
        return
      end
      device = actual_device
    end

    # Define directory based on type (folder_name) and locale
    base_screenshots_dir = "fastlane/metadata/android/#{locale}/images"
    target_dir = "#{base_screenshots_dir}/#{folder_name}"

    # Clean previous screenshots
    FileUtils.rm_rf(Dir.glob("#{target_dir}/*.png"))
    FileUtils.mkdir_p(target_dir)

    # Run Flutter integration test (light mode only)
    Dir.chdir("..") do
      ENV['FLUTTER_TEST_PLATFORM'] = 'android'
      ENV['TEST_LOCALE'] = locale
      ENV['SCREENSHOT_DIR'] = "android/#{target_dir}"

      command_args = [
        "fvm", "flutter", "drive",
        "--driver=test_driver/integration_test.dart",
        "--target=integration_test/screenshot_test.dart",
        "--dart-define=TEST_LOCALE=#{locale}",
        "--dart-define=SCREENSHOT_MODE=true",
        "-d", device
      ]

      if force_logout
        command_args << "--dart-define=FORCE_LOGOUT=#{force_logout}"
      end

      begin
        sh(*command_args)
      rescue => ex
        UI.error("‚ùå Error capturing screenshots for #{folder_name} on #{device} (#{locale}): #{ex}")
      end
    end

    # List captured screenshots
    screenshots = Dir.glob("#{target_dir}/*.png")
    UI.success("‚úÖ Captured #{screenshots.length} screenshots for #{folder_name} (#{locale})")
  end
end
