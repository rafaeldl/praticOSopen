default_platform(:android)

platform :android do
  desc "Runs all the tests"
  lane :test do
    gradle(task: "test")
  end

  desc "Build the Android App Bundle (AAB) using Flutter"
  lane :build_flutter do |options|
    version_code = options[:version_code]
    version_name = options[:version_name]
    
    # Constr√≥i o comando flutter build
    build_args = ["build", "appbundle", "--release"]
    build_args << "--build-number=#{version_code}" if version_code
    build_args << "--build-name=#{version_name}" if version_name

    # Executa o build do Flutter na raiz do projeto (../)
    Dir.chdir("..") do
      sh("flutter", *build_args)
    end
  end

  desc "Deploy a new version to the Google Play Internal Track"
  lane :internal do |options|
    # 1. Carregar credenciais
    
    # 2. Buscar vers√£o atual na loja
    begin
      current_codes = google_play_track_version_codes(track: 'internal')
      max_code = current_codes.max || 0
      prod_codes = google_play_track_version_codes(track: 'production')
      max_prod = prod_codes.max || 0
      
      current_version_code = [max_code, max_prod].max
    rescue => ex
      UI.error("Erro ao buscar vers√£o na loja: #{ex}")
      current_version_code = 0
    end

    new_version_code = current_version_code + 1
    UI.message("Version Code atual na loja: #{current_version_code}. Novo Version Code: #{new_version_code}")

    # 3. Buildar com o novo c√≥digo
    build_flutter(version_code: new_version_code)
    
    # 4. Upload (only binary, no metadata for RC)
    upload_to_play_store(
      track: 'internal',
      aab: '../build/app/outputs/bundle/release/app-release.aab',
      skip_upload_apk: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      skip_upload_metadata: true,
      skip_upload_changelogs: true
    )
  end

  desc "Deploy to Internal Track with Metadata and Screenshots"
  lane :deploy_with_metadata do |options|
    # Default track is internal, but can be overridden (e.g., 'production')
    track = options[:track] || 'internal'
    
    # Op√ß√µes para pular uploads se n√£o houver altera√ß√µes (detectado pelo CI)
    skip_screenshots = options[:skip_screenshots] || false
    skip_images = options[:skip_images] || false
    skip_metadata = options[:skip_metadata] || false

    # 1. Carregar credenciais (garante que json_key_data esteja dispon√≠vel se precisar)
    
    # 2. Buscar vers√£o atual na loja
    begin
      current_codes = google_play_track_version_codes(track: 'internal')
      max_code = current_codes.max || 0
      prod_codes = google_play_track_version_codes(track: 'production')
      max_prod = prod_codes.max || 0
      
      current_version_code = [max_code, max_prod].max
    rescue => ex
      UI.error("Erro ao buscar vers√£o na loja: #{ex}")
      current_version_code = 0
    end

    new_version_code = current_version_code + 1
    UI.message("Version Code atual na loja: #{current_version_code}. Novo Version Code: #{new_version_code}")

    # 3. Buildar com o novo c√≥digo
    build_flutter(version_code: new_version_code)

    # Define o caminho padr√£o ou usa a vari√°vel de ambiente se dispon√≠vel
    json_key_path = 'fastlane/play_store_credentials.json'
    json_key_data = ENV['ANDROID_PLAY_STORE_CREDENTIALS']

    # 4. Upload completo
    upload_to_play_store(
      track: track,
      aab: '../build/app/outputs/bundle/release/app-release.aab',
      # Usa o conte√∫do da vari√°vel de ambiente se existir, sen√£o usa o arquivo
      json_key_data: json_key_data, 
      json_key: json_key_data ? nil : json_key_path,
      skip_upload_apk: true,
      skip_upload_images: skip_images,      # Din√¢mico
      skip_upload_screenshots: skip_screenshots, # Din√¢mico
      skip_upload_metadata: skip_metadata     # Din√¢mico
    )
  end
  desc "Promote Internal to Production"
  lane :promote_to_production do |options|
    skip_screenshots = options[:skip_screenshots] || false

    # Get the version code from internal track
    version_codes = google_play_track_version_codes(track: 'internal')
    version_code = version_codes.max

    UI.message("Promoting version code #{version_code} from internal to production")

    upload_to_play_store(
      track: 'internal',
      track_promote_to: 'production',
      version_code: version_code,       # Specify version code for changelogs
      skip_upload_apk: true,
      skip_upload_aab: true,
      skip_upload_metadata: false,      # Always upload metadata
      skip_upload_changelogs: false,    # Always upload changelogs
      skip_upload_images: skip_screenshots,
      skip_upload_screenshots: skip_screenshots
    )
  end

  desc "Capture screenshots automatically using Flutter integration tests"
  lane :screenshots do |options|
    device = options[:device]
    avd_name = options[:avd] || options[:avd_name]
    locale = options[:locale] || "pt-BR"
    force_logout = options[:force_logout]

    # If AVD name provided, boot automatically. Otherwise use existing device.
    if avd_name
      UI.message("ü§ñ Will boot emulator automatically: #{avd_name}")
    elsif device
      UI.message("üì± Using existing device: #{device}")
    else
      UI.user_error!("‚ùå Must provide either :device or :avd parameter")
    end

    capture_screenshots_for_device(
      device: device,
      folder_name: "phoneScreenshots",
      locale: locale,
      force_logout: force_logout,
      avd_name: avd_name
    )
  end

  desc "Capture screenshots for all locales and all device types"
  lane :screenshots_all do |options|
    # AVD names (can be customized via options)
    # Run `emulator -list-avds` to see your available AVDs
    phone_avd = options[:phone_avd] || "Pixel_7"
    tablet7_avd = options[:tablet7_avd] || "Pixel_Tablet"
    tablet10_avd = options[:tablet10_avd] || "Pixel_Tablet"  # Using same as 7" if no 10" available

    force_logout = options[:force_logout]
    # Parallel is NOT supported when using auto-boot (emulators conflict)
    parallel = false
    locales = ["pt-BR", "en-US", "es-ES"]

    UI.important("ü§ñ Emulators will be started automatically!")
    UI.message("   üì± Phone: #{phone_avd}")
    UI.message("   üìü Tablet 7\": #{tablet7_avd}")
    UI.message("   üíª Tablet 10\": #{tablet10_avd}")

    locales.each do |locale|
      UI.message("üåç Generating screenshots for locale: #{locale}")
      UI.message("üêå Running devices in SEQUENTIAL mode (auto-boot)")

      # Phone
      capture_screenshots_for_device(
        device: nil,  # Will be determined after boot
        folder_name: "phoneScreenshots",
        locale: locale,
        force_logout: force_logout,
        avd_name: phone_avd
      )

      # 7-inch Tablet
      capture_screenshots_for_device(
        device: nil,
        folder_name: "sevenInchScreenshots",
        locale: locale,
        force_logout: force_logout,
        avd_name: tablet7_avd
      )

      # 10-inch Tablet
      capture_screenshots_for_device(
        device: nil,
        folder_name: "tenInchScreenshots",
        locale: locale,
        force_logout: force_logout,
        avd_name: tablet10_avd
      )
    end

    UI.success("‚úÖ All screenshots generated for #{locales.length} locales!")
  end

  desc "Capture screenshots only for pt-BR (backwards compatibility)"
  lane :screenshots_pt_br do |options|
    phone_device = options[:phone_device] || "emulator-5554"
    tablet7_device = options[:tablet7_device] || "emulator-5556"
    tablet10_device = options[:tablet10_device] || "emulator-5558"
    force_logout = options[:force_logout]

    # Phone
    capture_screenshots_for_device(
      device: phone_device,
      folder_name: "phoneScreenshots",
      locale: "pt-BR",
      force_logout: force_logout
    )

    # 7-inch Tablet
    capture_screenshots_for_device(
      device: tablet7_device,
      folder_name: "sevenInchScreenshots",
      locale: "pt-BR",
      force_logout: force_logout
    )

    # 10-inch Tablet
    capture_screenshots_for_device(
      device: tablet10_device,
      folder_name: "tenInchScreenshots",
      locale: "pt-BR",
      force_logout: force_logout
    )
  end

  # Helper function to get Android SDK path
  def get_android_sdk_path
    # Try ANDROID_HOME or ANDROID_SDK_ROOT environment variables
    sdk_path = ENV['ANDROID_HOME'] || ENV['ANDROID_SDK_ROOT']

    # If not set, try common locations
    if sdk_path.nil? || sdk_path.empty?
      common_paths = [
        File.expand_path("~/Library/Android/sdk"),     # macOS default
        File.expand_path("~/Android/Sdk"),             # Linux default
        "/usr/local/android-sdk"                       # Alternative
      ]

      sdk_path = common_paths.find { |path| Dir.exist?(path) }
    end

    if sdk_path.nil?
      UI.user_error!("‚ùå Android SDK not found. Please set ANDROID_HOME environment variable or install Android SDK.")
    end

    sdk_path
  end

  # Helper function to boot and reset emulator
  def boot_emulator(avd_name:, locale:)
    UI.message("üîÑ Preparing emulator: #{avd_name} with locale: #{locale}")

    # Get Android SDK paths
    sdk_path = get_android_sdk_path
    adb = File.join(sdk_path, "platform-tools", "adb")
    emulator = File.join(sdk_path, "emulator", "emulator")

    UI.message("Using Android SDK: #{sdk_path}")

    # 1. Kill emulator if already running
    UI.message("Killing any existing emulator instances...")
    sh("#{adb} devices | grep emulator | cut -f1 | xargs -I {} #{adb} -s {} emu kill || true")
    sleep(2)

    # 2. Start emulator fresh (no snapshot, wipe data for clean state)
    UI.message("üöÄ Starting emulator: #{avd_name}")
    spawn("#{emulator} -avd #{avd_name} -no-snapshot-load -no-audio -no-boot-anim")

    # 3. Wait for emulator to boot (check boot_completed property)
    UI.message("‚è≥ Waiting for emulator to boot...")
    max_attempts = 60
    attempts = 0
    booted = false

    while attempts < max_attempts && !booted
      sleep(5)
      attempts += 1

      # Get first emulator device
      device = `#{adb} devices | grep emulator | head -1 | cut -f1`.strip

      if !device.empty?
        boot_status = `#{adb} -s #{device} shell getprop sys.boot_completed 2>/dev/null`.strip
        if boot_status == "1"
          booted = true
          UI.message("‚úÖ Emulator booted: #{device}")

          # 4. Set locale
          UI.message("üåç Setting locale to: #{locale}")

          # Map locale to Android format
          android_locale = case locale
            when "pt-BR" then "pt-BR"
            when "en-US" then "en-US"
            when "es-ES" then "es-ES"
            else "en-US"
          end

          # Set system locale
          sh("#{adb} -s #{device} shell settings put system system_locales #{android_locale}") rescue nil
          sh("#{adb} -s #{device} shell setprop persist.sys.locale #{android_locale}") rescue nil

          # 5. Restart UI to apply locale
          UI.message("Restarting UI to apply locale...")
          sh("#{adb} -s #{device} shell stop") rescue nil
          sleep(2)
          sh("#{adb} -s #{device} shell start") rescue nil
          sleep(5)

          # 6. Wait for boot_completed again after restart
          UI.message("‚è≥ Waiting for UI to restart...")
          wait_attempts = 0
          ui_ready = false
          while wait_attempts < 20 && !ui_ready
            sleep(2)
            wait_attempts += 1
            boot_status = `#{adb} -s #{device} shell getprop sys.boot_completed 2>/dev/null`.strip
            if boot_status == "1"
              ui_ready = true
              UI.success("‚úÖ Emulator ready: #{device} (locale: #{locale})")
            end
          end

          return device
        end
      end
    end

    UI.error("‚ùå Emulator failed to boot after #{max_attempts * 5} seconds")
    nil
  end

  # Helper function to run the screenshot process
  def capture_screenshots_for_device(device:, folder_name:, locale:, force_logout:, avd_name: nil)
    UI.message("üì∏ Capturing screenshots for #{folder_name} on device: #{device}, locale: #{locale}")

    # Boot emulator if AVD name provided
    if avd_name
      actual_device = boot_emulator(avd_name: avd_name, locale: locale)
      if actual_device.nil?
        UI.error("‚ö†Ô∏è Failed to boot emulator, skipping screenshots")
        return
      end
      device = actual_device
    end

    # Define o diret√≥rio baseado no tipo (folder_name) e locale
    base_screenshots_dir = "fastlane/metadata/android/#{locale}/images"
    target_dir = "#{base_screenshots_dir}/#{folder_name}"

    # Limpa screenshots anteriores desse tipo
    FileUtils.rm_rf(Dir.glob("#{target_dir}/*.png"))
    FileUtils.mkdir_p(target_dir)

    # Executa o teste de integra√ß√£o Flutter
    Dir.chdir("..") do
      ENV['FLUTTER_TEST_PLATFORM'] = 'android'
      ENV['TEST_LOCALE'] = locale
      # Passa o diret√≥rio de destino para o driver Dart via vari√°vel de ambiente
      ENV['SCREENSHOT_DIR'] = "android/#{target_dir}"

      command_args = [
        "fvm", "flutter", "drive",
        "--driver=test_driver/integration_test.dart",
        "--target=integration_test/screenshot_test.dart",
        "--dart-define=TEST_LOCALE=#{locale}",
        "-d", device
      ]

      if force_logout
        command_args << "--dart-define=FORCE_LOGOUT=#{force_logout}"
      end

      begin
        sh(*command_args)
      rescue => ex
        UI.error("‚ùå Error capturing screenshots for #{folder_name} on #{device} (#{locale}): #{ex}")
        # N√£o para o processo inteiro se um falhar, mas avisa
      end
    end

    # Lista screenshots capturadas
    screenshots = Dir.glob("#{target_dir}/*.png")
    UI.success("‚úÖ Captured #{screenshots.length} screenshots for #{folder_name} (#{locale})")
  end
end
