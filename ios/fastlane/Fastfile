default_platform(:ios)

platform :ios do
  desc "Retorna o prÃ³ximo build number (Ãºltimo do TestFlight + 1)"
  lane :get_next_build_number do
    app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID'],
      key_content: ENV['APP_STORE_CONNECT_API_KEY_PRIVATE_KEY']
    )

    current = latest_testflight_build_number(app_identifier: ENV['BUNDLE_ID'])
    next_build = current + 1
    UI.message("Current build: #{current}, Next build: #{next_build}")

    # Escreve o nÃºmero em um arquivo para o CI ler
    File.write("../next_build_number.txt", next_build.to_s)
    next_build
  end

  desc "Build + upload para TestFlight (sem match)"
  lane :beta do
    app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID'],
      key_content: ENV['APP_STORE_CONNECT_API_KEY_PRIVATE_KEY']
    )

    # Busca o prÃ³ximo build number
    current_build = latest_testflight_build_number(app_identifier: ENV['BUNDLE_ID'])
    next_build = current_build + 1
    UI.message("Current build: #{current_build}, Next build: #{next_build}")

    # ðŸ—ï¸ Flutter build com build number correto (sem code sign)
    Dir.chdir("..") do
      sh("flutter", "build", "ios", "--release", "--no-codesign", "--build-number=#{next_build}")
    end

    # ðŸ”§ forÃ§a assinatura sÃ³ no Runner (Release)
    update_code_signing_settings(
      use_automatic_signing: false,
      path: "Runner.xcodeproj",
      targets: ["Runner"],
      build_configurations: ["Release"],
      team_id: ENV['DEVELOPMENT_TEAM'],
      code_sign_identity: "Apple Distribution",
      profile_name: ENV['PROFILE_NAME'],   # nome do .mobileprovision (o "Name" extraÃ­do)
      profile_uuid: ENV['PROFILE_UUID']    # opcional, ajuda a fixar
    )

    # ðŸ—ï¸ archive + export
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      configuration: "Release",
      export_method: "app-store",
      skip_profile_detection: true,
      export_options: {
        signingStyle: "manual",
        provisioningProfiles: {
          ENV['BUNDLE_ID'] => ENV['PROFILE_NAME']
        }
      },
      xcargs: "DEVELOPMENT_TEAM=#{ENV['DEVELOPMENT_TEAM']} CODE_SIGN_STYLE=Manual"
    )

    upload_to_testflight(
      skip_waiting_for_build_processing: true
    )
  end

  desc "SÃ³ envia o Ãºltimo .ipa do diretÃ³rio padrÃ£o do Fastlane"
  lane :upload_last do
    upload_to_testflight(skip_waiting_for_build_processing: true)
  end

  desc "Upload do IPA gerado pelo Flutter build"
  lane :upload do
    app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID'],
      key_content: ENV['APP_STORE_CONNECT_API_KEY_PRIVATE_KEY']
    )

    # Busca o IPA gerado pelo Flutter (encontra qualquer .ipa no diretÃ³rio)
    ipa_dir = "../build/ios/ipa"
    ipa_files = Dir.glob("#{ipa_dir}/*.ipa")

    if ipa_files.empty?
      UI.user_error!("Nenhum arquivo .ipa encontrado em #{ipa_dir}")
    end

    ipa_path = ipa_files.first
    UI.message("Usando IPA: #{ipa_path}")

    upload_to_testflight(
      ipa: ipa_path,
      skip_waiting_for_build_processing: true
    )
  end

  desc "Build + Upload para App Store (com metadados e screenshots)"
  lane :release_store do
    app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID'],
      key_content: ENV['APP_STORE_CONNECT_API_KEY_PRIVATE_KEY']
    )

    # Busca o prÃ³ximo build number
    current_build = latest_testflight_build_number(app_identifier: ENV['BUNDLE_ID'])
    next_build = current_build + 1
    UI.message("Current build: #{current_build}, Next build: #{next_build}")

    # ðŸ—ï¸ Flutter build com build number correto (sem code sign)
    Dir.chdir("..") do
      sh("flutter", "build", "ios", "--release", "--no-codesign", "--build-number=#{next_build}")
    end

    # ðŸ”§ forÃ§a assinatura sÃ³ no Runner (Release)
    update_code_signing_settings(
      use_automatic_signing: false,
      path: "Runner.xcodeproj",
      targets: ["Runner"],
      build_configurations: ["Release"],
      team_id: ENV['DEVELOPMENT_TEAM'],
      code_sign_identity: "Apple Distribution",
      profile_name: ENV['PROFILE_NAME'],
      profile_uuid: ENV['PROFILE_UUID']
    )

    # ðŸ—ï¸ archive + export
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      configuration: "Release",
      export_method: "app-store",
      skip_profile_detection: true,
      export_options: {
        signingStyle: "manual",
        provisioningProfiles: {
          ENV['BUNDLE_ID'] => ENV['PROFILE_NAME']
        }
      },
      xcargs: "DEVELOPMENT_TEAM=#{ENV['DEVELOPMENT_TEAM']} CODE_SIGN_STYLE=Manual"
    )

    # ðŸš€ Upload para App Store
    upload_to_app_store(
      force: true, # Pula confirmaÃ§Ã£o de HTML preview
      skip_screenshots: false,
      skip_metadata: false,
      submit_for_review: false, # Apenas upload, revisÃ£o manual
      run_precheck_before_submit: false # Evita erro de API Key com IAP
    )
  end

  desc "Gera screenshots automaticamente usando Flutter integration tests"
  lane :screenshots do |options|
    device = options[:device] || "iPhone 16e"
    device_id = options[:device_id] # UDID do simulador (opcional)
    force_logout = options[:force_logout]

    UI.message("ðŸ“¸ Capturing screenshots on device: #{device}")

    # Limpa screenshots anteriores
    screenshots_dir = "fastlane/screenshots/pt-BR"
    FileUtils.rm_rf(Dir.glob("#{screenshots_dir}/#{device}*.png"))
    FileUtils.mkdir_p(screenshots_dir)

    # Determina o device ID
    target_device = device_id || device

    # Executa o teste de integraÃ§Ã£o Flutter
    Dir.chdir("..") do
      ENV['FLUTTER_TEST_PLATFORM'] = 'ios'
      ENV['DEVICE_NAME'] = device
      
      command_args = [
        "fvm", "flutter", "drive",
        "--driver=test_driver/integration_test.dart",
        "--target=integration_test/screenshot_test.dart",
        "-d", target_device
      ]
      
      # Adiciona o parÃ¢metro force_logout se fornecido
      if force_logout
        command_args << "--dart-define=FORCE_LOGOUT=#{force_logout}"
      end
      
      sh(*command_args)
    end

    # Lista screenshots capturadas
    screenshots = Dir.glob("#{screenshots_dir}/#{device}*.png")
    UI.success("âœ… Captured #{screenshots.length} screenshots:")
    screenshots.each { |s| UI.message("   - #{s}") }
  end
end
