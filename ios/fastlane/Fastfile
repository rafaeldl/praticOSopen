default_platform(:ios)

platform :ios do
  desc "Build check para CI (simulador, sem assinatura)"
  lane :build_check do
    # Gera arquivos Flutter necess√°rios (n√£o faz build completo, n√£o roda pod install)
    Dir.chdir("..") do
      sh("flutter", "build", "ios", "--config-only", "--simulator", "--debug")
    end

    # Build com xcodebuild para simulador (n√£o precisa de certificados)
    xcodebuild(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      configuration: "Debug",
      destination: "generic/platform=iOS Simulator",
      xcargs: "CODE_SIGNING_ALLOWED=NO CODE_SIGNING_REQUIRED=NO"
    )

    UI.success("‚úÖ Build check conclu√≠do com sucesso!")
  end

  desc "Retorna o pr√≥ximo build number (√∫ltimo do TestFlight + 1)"
  lane :get_next_build_number do
    app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID'],
      key_content: ENV['APP_STORE_CONNECT_API_KEY_PRIVATE_KEY']
    )

    current = latest_testflight_build_number(app_identifier: ENV['BUNDLE_ID'])
    next_build = current + 1
    UI.message("Current build: #{current}, Next build: #{next_build}")

    # Escreve o n√∫mero em um arquivo para o CI ler
    File.write("../next_build_number.txt", next_build.to_s)
    next_build
  end

  desc "Build + upload para TestFlight (sem match)"
  lane :beta do
    app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID'],
      key_content: ENV['APP_STORE_CONNECT_API_KEY_PRIVATE_KEY']
    )

    # Busca o pr√≥ximo build number
    current_build = latest_testflight_build_number(app_identifier: ENV['BUNDLE_ID'])
    next_build = current_build + 1
    UI.message("Current build: #{current_build}, Next build: #{next_build}")

    # üèóÔ∏è Flutter build com build number correto (sem code sign)
    Dir.chdir("..") do
      sh("flutter", "build", "ios", "--release", "--no-codesign", "--build-number=#{next_build}")
    end

    # üîß for√ßa assinatura s√≥ no Runner (Release)
    update_code_signing_settings(
      use_automatic_signing: false,
      path: "Runner.xcodeproj",
      targets: ["Runner"],
      build_configurations: ["Release"],
      team_id: ENV['DEVELOPMENT_TEAM'],
      code_sign_identity: "Apple Distribution",
      profile_name: ENV['PROFILE_NAME'],   # nome do .mobileprovision (o "Name" extra√≠do)
      profile_uuid: ENV['PROFILE_UUID']    # opcional, ajuda a fixar
    )

    # üèóÔ∏è archive + export
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      configuration: "Release",
      export_method: "app-store",
      skip_profile_detection: true,
      export_options: {
        signingStyle: "manual",
        provisioningProfiles: {
          ENV['BUNDLE_ID'] => ENV['PROFILE_NAME']
        }
      },
      xcargs: "DEVELOPMENT_TEAM=#{ENV['DEVELOPMENT_TEAM']} CODE_SIGN_STYLE=Manual"
    )

    upload_to_testflight(
      skip_waiting_for_build_processing: true
    )
  end

  desc "S√≥ envia o √∫ltimo .ipa do diret√≥rio padr√£o do Fastlane"
  lane :upload_last do
    upload_to_testflight(skip_waiting_for_build_processing: true)
  end

  desc "Upload do IPA gerado pelo Flutter build"
  lane :upload do
    app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID'],
      key_content: ENV['APP_STORE_CONNECT_API_KEY_PRIVATE_KEY']
    )

    # Busca o IPA gerado pelo Flutter (encontra qualquer .ipa no diret√≥rio)
    ipa_dir = "../build/ios/ipa"
    ipa_files = Dir.glob("#{ipa_dir}/*.ipa")

    if ipa_files.empty?
      UI.user_error!("Nenhum arquivo .ipa encontrado em #{ipa_dir}")
    end

    ipa_path = ipa_files.first
    UI.message("Usando IPA: #{ipa_path}")

    upload_to_testflight(
      ipa: ipa_path,
      skip_waiting_for_build_processing: true
    )
  end

  desc "Build + Upload para App Store (com metadados e screenshots)"
  lane :release_store do |options|
    skip_screenshots = options[:skip_screenshots] || false
    skip_metadata = options[:skip_metadata] || false

    app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID'],
      key_content: ENV['APP_STORE_CONNECT_API_KEY_PRIVATE_KEY']
    )

    # Busca o pr√≥ximo build number
    current_build = latest_testflight_build_number(app_identifier: ENV['BUNDLE_ID'])
    next_build = current_build + 1
    UI.message("Current build: #{current_build}, Next build: #{next_build}")

    # üèóÔ∏è Flutter build com build number correto (sem code sign)
    Dir.chdir("..") do
      sh("flutter", "build", "ios", "--release", "--no-codesign", "--build-number=#{next_build}")
    end

    # üîß for√ßa assinatura s√≥ no Runner (Release)
    update_code_signing_settings(
      use_automatic_signing: false,
      path: "Runner.xcodeproj",
      targets: ["Runner"],
      build_configurations: ["Release"],
      team_id: ENV['DEVELOPMENT_TEAM'],
      code_sign_identity: "Apple Distribution",
      profile_name: ENV['PROFILE_NAME'],
      profile_uuid: ENV['PROFILE_UUID']
    )

    # üèóÔ∏è archive + export
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      configuration: "Release",
      export_method: "app-store",
      skip_profile_detection: true,
      export_options: {
        signingStyle: "manual",
        provisioningProfiles: {
          ENV['BUNDLE_ID'] => ENV['PROFILE_NAME']
        }
      },
      xcargs: "DEVELOPMENT_TEAM=#{ENV['DEVELOPMENT_TEAM']} CODE_SIGN_STYLE=Manual"
    )

    # üöÄ Upload para App Store
    upload_to_app_store(
      force: true, # Pula confirma√ß√£o de HTML preview
      skip_screenshots: skip_screenshots,
      skip_metadata: skip_metadata,
      submit_for_review: false, # Apenas upload, revis√£o manual
      run_precheck_before_submit: false # Evita erro de API Key com IAP
    )
  end

  desc "Remove alpha channel from all screenshots (required by App Store)"
  lane :fix_screenshots_alpha do
    # Use absolute path to avoid working directory issues
    screenshots_dir = File.expand_path("../fastlane/screenshots", __dir__)

    UI.message("üîß Removing alpha channel from screenshots...")
    UI.message("üìÅ Screenshots directory: #{screenshots_dir}")

    # Find all PNG files in screenshots directory
    png_files = Dir.glob("#{screenshots_dir}/**/*.png")

    if png_files.empty?
      UI.important("No PNG files found in #{screenshots_dir}")
      next
    end

    UI.message("Found #{png_files.length} PNG files to process")

    png_files.each do |file|
      # Use sips (macOS built-in) to remove alpha by converting to JPEG and back
      # This is a reliable way to strip alpha channel without needing ImageMagick
      temp_file = "#{file}.temp.jpg"

      begin
        # Convert to JPEG (removes alpha)
        sh("sips", "-s", "format", "jpeg", "-s", "formatOptions", "100", file, "--out", temp_file, exception: false)

        # Convert back to PNG (RGB, no alpha)
        sh("sips", "-s", "format", "png", temp_file, "--out", file, exception: false)

        # Clean up temp file
        FileUtils.rm_f(temp_file)
      rescue => ex
        UI.error("Error processing #{file}: #{ex}")
      end
    end

    UI.success("‚úÖ Alpha channel removed from #{png_files.length} screenshots")
  end

  desc "Promote TestFlight build to App Store (no re-upload)"
  lane :promote do |options|
    skip_screenshots = options.fetch(:skip_screenshots, true)
    app_version = options[:app_version]

    # Fix alpha channel in screenshots before upload
    unless skip_screenshots
      fix_screenshots_alpha
    end

    app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID'],
      key_content: ENV['APP_STORE_CONNECT_API_KEY_PRIVATE_KEY']
    )

    # Step 1: Upload metadata and screenshots WITHOUT submitting
    # This allows time for screenshot processing
    UI.message("üì§ Uploading metadata and screenshots...")
    upload_to_app_store(
      app_version: app_version,
      skip_binary_upload: true,
      force: true,
      skip_screenshots: skip_screenshots,
      skip_metadata: false,
      overwrite_screenshots: true,
      ignore_language_directory_validation: true,
      screenshots_path: "./fastlane/screenshots",
      submit_for_review: false,  # Don't submit yet - wait for screenshots to process
      reject_if_possible: true,
      run_precheck_before_submit: false,
      precheck_default_rule_level: :skip
    )

    # Step 2: Submit for review with retry logic
    # Apple needs time to process uploaded screenshots before submission
    max_retries = 5
    retry_delay = 90  # Start with 90 seconds for many screenshots

    (1..max_retries).each do |attempt|
      if !skip_screenshots && attempt == 1
        UI.message("‚è≥ Waiting #{retry_delay} seconds for screenshot processing...")
        sleep(retry_delay)
      end

      UI.message("üöÄ Submitting for App Store review (attempt #{attempt}/#{max_retries})...")
      begin
        upload_to_app_store(
          app_version: app_version,
          skip_binary_upload: true,
          force: true,
          skip_screenshots: true,  # Already uploaded
          skip_metadata: true,     # Already uploaded
          submit_for_review: true,
          reject_if_possible: false,  # Already rejected in step 1 if needed
          run_precheck_before_submit: false,
          precheck_default_rule_level: :skip
        )
        UI.success("‚úÖ App submitted for App Store review!")
        break  # Success - exit retry loop
      rescue => e
        if e.message.include?("still in progress") && attempt < max_retries
          wait_time = 60 * attempt  # Exponential: 60, 120, 180, 240 seconds
          UI.important("‚ö†Ô∏è Screenshots still processing, waiting #{wait_time}s before retry...")
          sleep(wait_time)
        else
          raise e  # Re-raise if not a screenshot issue or last attempt
        end
      end
    end
  end

  desc "Clear all screenshots from App Store Connect (useful before fresh upload)"
  lane :clear_screenshots do |options|
    app_version = options[:app_version]

    app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID'],
      key_content: ENV['APP_STORE_CONNECT_API_KEY_PRIVATE_KEY']
    )

    # Upload with empty screenshots to clear existing ones
    # This is a workaround for when overwrite_screenshots doesn't work as expected
    UI.message("üóëÔ∏è Clearing all screenshots from App Store Connect...")

    # Create temp empty screenshots directory
    empty_screenshots_dir = "/tmp/empty_screenshots"
    FileUtils.rm_rf(empty_screenshots_dir)
    FileUtils.mkdir_p("#{empty_screenshots_dir}/pt-BR")
    FileUtils.mkdir_p("#{empty_screenshots_dir}/en-US")
    FileUtils.mkdir_p("#{empty_screenshots_dir}/es-ES")

    upload_to_app_store(
      app_version: app_version,
      skip_binary_upload: true,
      force: true,
      skip_screenshots: false,
      skip_metadata: true,
      overwrite_screenshots: true,
      screenshots_path: empty_screenshots_dir,
      submit_for_review: false,
      run_precheck_before_submit: false
    )

    # Cleanup
    FileUtils.rm_rf(empty_screenshots_dir)

    UI.success("‚úÖ Screenshots cleared! Now run 'fastlane promote skip_screenshots:false' to upload new ones.")
  end

  desc "Gera screenshots automaticamente usando Flutter integration tests"
  lane :screenshots do |options|
    device = options[:device] || "iPhone 16e"
    locale = options[:locale] || "pt-BR"
    force_logout = options[:force_logout]

    capture_ios_screenshots(device: device, locale: locale, force_logout: force_logout)
  end

  desc "Gera screenshots para todos dispositivos e idiomas"
  lane :screenshots_all do |options|
    force_logout = options[:force_logout]
    parallel = options[:parallel] == true  # Default: false (changed for debugging)
    locales = ["pt-BR", "en-US", "es-ES"]
    devices = ["iPhone 16e", "iPhone 17", "iPhone 17 Pro Max"]

    locales.each do |locale|
      UI.message("üåç Generating screenshots for locale: #{locale}")

      if parallel
        UI.important("‚ö° Running devices in PARALLEL mode")

        # Run devices in parallel using threads
        threads = devices.map do |device|
          Thread.new do
            capture_ios_screenshots(device: device, locale: locale, force_logout: force_logout)
          end
        end

        # Wait for all threads to complete
        threads.each(&:join)
      else
        UI.message("üêå Running devices in SEQUENTIAL mode")

        # Run devices sequentially (original behavior)
        devices.each do |device|
          capture_ios_screenshots(device: device, locale: locale, force_logout: force_logout)
        end
      end
    end

    UI.success("‚úÖ All screenshots generated for #{locales.length} locales and #{devices.length} devices!")
  end

  desc "Gera screenshots apenas para pt-BR (backwards compatibility)"
  lane :screenshots_pt_br do |options|
    force_logout = options[:force_logout]
    devices = ["iPhone 16e", "iPhone 17", "iPhone 17 Pro Max"]

    devices.each do |device|
      capture_ios_screenshots(device: device, locale: "pt-BR", force_logout: force_logout)
    end
  end

  # Helper function for iOS screenshots (light mode only)
  def capture_ios_screenshots(device:, locale:, force_logout:)
    UI.message("üì∏ Capturing screenshots on device: #{device}, locale: #{locale}")

    # Clean previous screenshots for this device and locale
    screenshots_dir = "fastlane/screenshots/#{locale}"
    FileUtils.rm_rf(Dir.glob("#{screenshots_dir}/#{device}*.png"))
    FileUtils.mkdir_p(screenshots_dir)

    # Reset simulator to clean state before each test
    UI.message("üîÑ Resetting simulator to clean state: #{device}")
    begin
      # 1. Shutdown simulator if running
      UI.message("Shutting down simulator if running...")
      sh("xcrun simctl shutdown '#{device}' || true")
      sleep(2)

      # 2. Erase all data (factory reset)
      UI.message("Erasing simulator data (factory reset)...")
      sh("xcrun", "simctl", "erase", device)
      sleep(2)

      # 3. Boot fresh simulator
      UI.message("üöÄ Booting fresh simulator: #{device}")
      sh("xcrun", "simctl", "boot", device)
      sh("open", "-a", "Simulator")

      # 4. Wait for simulator to be fully ready
      UI.message("‚è≥ Waiting for simulator to boot...")
      sleep(10)

      # 5. Set light mode appearance
      UI.message("üåû Setting light mode appearance...")
      sh("xcrun", "simctl", "ui", device, "appearance", "light") rescue nil
      sleep(2)

      UI.success("‚úÖ Simulator ready: #{device}")
    rescue => ex
      UI.error("‚ö†Ô∏è Error resetting simulator: #{ex}")
      UI.message("Continuing anyway, Flutter might handle it...")
    end

    # Run Flutter integration test (light mode only)
    Dir.chdir("..") do
      ENV['FLUTTER_TEST_PLATFORM'] = 'ios'
      ENV['DEVICE_NAME'] = device
      ENV['TEST_LOCALE'] = locale

      command_args = [
        "fvm", "flutter", "drive",
        "--driver=test_driver/integration_test.dart",
        "--target=integration_test/screenshot_test.dart",
        "--dart-define=TEST_LOCALE=#{locale}",
        "-d", device
      ]

      if force_logout
        command_args << "--dart-define=FORCE_LOGOUT=#{force_logout}"
      end

      begin
        sh(*command_args)
      rescue => ex
        UI.error("‚ùå Error capturing screenshots for #{device} (#{locale}): #{ex}")
      end
    end

    # List captured screenshots
    screenshots = Dir.glob("#{screenshots_dir}/#{device}*.png")
    UI.success("‚úÖ Captured #{screenshots.length} screenshots for #{device} (#{locale})")
  end
end
